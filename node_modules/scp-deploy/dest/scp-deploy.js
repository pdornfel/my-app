'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var colors = require('colors');
var path = require('path');
var scpClient = require('scp2');
var Client = scpClient.Client;
var rd = require('rd');
var ProgressBar = require('progress');
var fs = require('fs-extra');

var scpDeploy = function () {
  function scpDeploy(options) {
    _classCallCheck(this, scpDeploy);

    return this.index.bind(this);
  }

  _createClass(scpDeploy, [{
    key: 'index',
    value: function index() {
      var _this = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.options = options;
      this.info = {};
      this.copy2tmp().then(function () {
        _this.fileData = _this.statFiles('./tmp/');
        _this.client = new Client();
        _this.progress = _this.createProgress();
        _this.upload('./tmp/');
      });
      return this.returnPromise();
    }
  }, {
    key: 'copy2tmp',
    value: function copy2tmp() {
      var _this2 = this;

      if (typeof this.options.src === 'string') this.options.src = [this.options.src];
      var promise = new Promise(function (resolve, reject) {
        _this2.removePath('./tmp/').then(function () {
          _this2.options.src.map(function (item) {
            _this2.copy({
              src: item
            });
          });
          resolve();
        });
      });
      return promise;
    }
  }, {
    key: 'copy',
    value: function copy(options) {
      if (!options.src) return;
      if (typeof options.src !== 'string') return;
      options.includeSub = false;
      if (options.src.indexOf('**') > -1) {
        options.includeSub = true;
      }
      if (/(\.\w+)$/.test(options.src)) {
        options.filetype = RegExp.$1;
      }
      options.src = options.src.replace(/\*+\S*$/, '');
      var s = fs.lstatSync(options.src);
      // single file
      if (!fs.lstatSync(options.src).isDirectory()) {
        var filenameReg = /([^\\/]+)$/;
        var filename = options.src.match(filenameReg);
        if (filename && filename.length) filename = filename[0];
        fs.copySync(options.src, './tmp/' + filename);
        return;
      }

      // copy path
      fs.copySync(options.src, './tmp/', {
        filter: function filter(src, dest) {
          var s = fs.lstatSync(src);
          // filter subpath files
          if (!options.includeSub) {
            var regxSub = /(\\+)?tmp\\+(\w+)(\\+)+/;
            if (regxSub.test(dest)) {
              return false;
            }
          }
          // filter subpath folder
          if (!options.includeSub && s.isDirectory()) {
            var _regxSub = /(\\+)?tmp\\+(\w+)(\\+)?/;
            if (_regxSub.test(dest)) {
              return false;
            }
          }
          // filter filetype
          if (options.filetype && !s.isDirectory()) {
            var regxFiletype = options.filetype + '$';
            regxFiletype = new RegExp(regxFiletype);
            if (!regxFiletype.test(src)) {
              return false;
            }
          }
          return true;
        }
      });
    }
  }, {
    key: 'createTemp',
    value: function createTemp() {
      var _this3 = this;

      var promise = new Promise(function (resolve, reject) {
        _this3.removePath('./tmp/').then(function () {
          return _this3.mkdir('./tmp/');
        }).then(function () {
          resolve();
        });
      });
      return promise;
    }
  }, {
    key: 'removePath',
    value: function removePath(src) {
      var promise = new Promise(function (resolve, reject) {
        fs.remove(src, function (err) {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
      return promise;
    }
  }, {
    key: 'mkdir',
    value: function mkdir(src) {
      var promise = new Promise(function (resolve, reject) {
        fs.mkdirp(src, function (err) {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
      return promise;
    }
  }, {
    key: 'upload',
    value: function upload(src) {
      var _this4 = this;

      this.info.startTime = new Date();
      var config = {};
      'host|port|username|password|path'.split('|').map(function (item) {
        config[item] = _this4.options[item];
      });
      scpClient.scp(src || this.options.src, config, this.client, function (err) {
        if (!(err && err.stack)) return;
        console.log(colors.red(err.stack));
        _this4.onDeployError(err.stack);
      });
      this.addEventsListener();
      console.log(colors.gray('[' + this.info.startTime.toLocaleTimeString() + '] ') + colors.green('Try to connect to server>') + colors.green.underline('ssh://' + this.options.host + ':' + this.options.port));
      this.connectTimer = setTimeout(function () {
        console.log(colors.gray('[' + new Date().toLocaleTimeString() + '] ') + colors.red('connect timeout'));
        process.exit();
      }, 6000);
    }
  }, {
    key: 'onConnect',
    value: function onConnect() {
      if (this.connectTimer) {
        clearTimeout(this.connectTimer);
        this.connectTimer = null;
      }
      console.log(colors.gray('[' + this.info.startTime.toLocaleTimeString() + '] ') + colors.green('Success connect  to server>') + colors.green.underline('ssh://' + this.options.host + ':' + this.options.port));
    }
  }, {
    key: 'onSuccess',
    value: function onSuccess(file) {
      this.progress.tick(1);
    }
  }, {
    key: 'onEnd',
    value: function onEnd() {
      var s1 = colors.magenta.underline;
      console.log('\ndeploy from \n' + s1(path.resolve(this.options.src.join('\n'))) + ' \nto ' + s1(this.options.host + ':' + this.options.port + this.options.path) + ' Done!');
      console.log(colors.gray('[' + this.info.uploadedTime.toLocaleTimeString() + '] ') + ('spend time: ' + colors.green(this.info.uploadedTime - this.info.startTime) + ' ms'));
      this.onDeployEnd();
    }
  }, {
    key: 'returnPromise',
    value: function returnPromise() {
      var _this5 = this;

      var promise = new Promise(function (resolve, reject) {
        _this5.onDeployEnd = function () {
          _this5.removePath('./tmp');
          resolve(_this5.info);
        };
        _this5.onDeployError = function (errMsg) {
          _this5.removePath('./tmp');
          reject(errMsg);
        };
      });
      return promise;
    }
  }, {
    key: 'addEventsListener',
    value: function addEventsListener() {
      var _this6 = this;

      this.client.on('connect', function (e) {
        _this6.info.connetedTime = new Date();
        _this6.onConnect();
      });

      this.client.on('write', function (obj) {
        _this6.onSuccess(obj.source);
      });

      this.client.on('end', function () {
        _this6.info.uploadedTime = new Date();
        _this6.onEnd();
      });
    }
  }, {
    key: 'createProgress',
    value: function createProgress() {
      var progress = new ProgressBar('[:bar] :current/:total (:percent)', {
        total: this.fileData.filesCount,
        width: this.options.processWidth || 30,
        incomplete: '-',
        complete: '+'
      });
      return progress;
    }
  }, {
    key: 'statFiles',
    value: function statFiles(path) {
      var data = {
        filesCount: 0,
        totalFilesize: 0
      };
      rd.eachSync(path, function (f, s) {
        if (!s.size) return;
        var stat = fs.lstatSync(f);
        if (stat.isDirectory()) return;
        data[f] = s.size;
        data.totalFilesize += s.size;
        data.filesCount += 1;
      });
      this.info.totalFilesize = data.totalFilesize;
      this.info.filesCount = data.filesCount;
      return data;
    }
  }]);

  return scpDeploy;
}();

module.exports = new scpDeploy();